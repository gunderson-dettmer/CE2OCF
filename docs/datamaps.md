# Datamap Basics

## Overview

The `traverse_datamap()` function described in the [crawler documentation](configuring datamap lookups.md) works in tandem with a number of
data schema building-blocks that let you describe very complex objects you'd like to create from CE JSONs. Depending
on how you put these together, you can get very complex behavior.

The datamap Python objects define a target data shape. The specific values you look up from CE to populate that
data structure can then be defined in a matching, readily configurable datamap JSON. We've provided our
[JSON datamaps](../Ce2Ocf/datamap/defaults) and these are used by default. The datamaps can be loaded from .json files
thanks to pydantic, so you can reconfigure ce<sub>2</sub>OCF with very little code.

The [base datamap types](../Ce2Ocf/datamap/definitions.py) are essentially templates that describe different ways to
transform a flat list of responses into given structure. They define the target object schema and specify how
to lookup values from the responses map to this schema (**but not what CE values to lookup**). The lookup instructions
are in the JSON configurations mentioned above. This lets us separate the lookup instructions from the target data shape
and (hopefully) makes this tool much more useful as you can set it up purely in JSON configurations once you define a
given set of schemas using datamap objects. We've built [OCF-specific datamaps schemas](../Ce2Ocf/ocf/datamaps.py) to
produce OCF from CE, but you could use our building blocks and parsing code to create other objects for other purposes.

## Datamap Building Blocks

Each of our [abstract datamap types](../Ce2Ocf/datamap/definitions.py) has a specific use:

- `FieldPostProcessorModel`: This is a base template that allows for post-processing of individual fields. It's like a
  blueprint that not only tells you what the final structure should look like, but also how to refine the raw results of
  each property - e.g. you might **(1)** define a json that tells the parser to look up some enums from CE and then use
  a post processor to run these values through a function to produce OCF (this is how we handle vesting at Gunderson),
  or **(2)** you might register a post-processor for phone numbers to ensure resulting #s conform to OCF specifications.
  </br></br>

    - `RepeatableDataMap`: This template is used for handling repeated data structures. It allows you to specify a
    pattern that should be repeated a certain number of times, and variables that should be applied to all iterations.
    The repeated data structure is treated exactly like a FieldPostProcessorModel, so if you register a field post
    processor for a `RepeatableDataMap` like `StockholderDataMap`:
    ```python
        class StockholderDataMap(FieldPostProcessorModel):
            id: Union[str, OverridableStringField] = Field(default_factory=lambda: {"static": uuid.uuid4().__str__()})
            object_type: OverridableStringField = Field(default_factory=lambda: {"static": "STAKEHOLDER"})
            name: StockholderInfoDataMap
            stakeholder_type: OverridableStringField = Field(default_factory=lambda: {"static": "INDIVIDUAL"})
            issuer_assigned_id: Union[str, OverridableStringField]
            current_relationship: Union[str, OverridableStringField] = Field(default_factory=lambda: {"static": "FOUNDER"})
            primary_contact: StockholderPrimaryContact
            addresses: list[AddressDataMap]
            tax_ids: list = []
            comments: list[Union[str, OverridableStringField]]
    ```
    such post processor is applied to the relevant field in the repeated pattern. For example in this json datamap
    representing our CE to OCF configuration for stockholder:
    ```json
      {
        "repeat_count": "NumberStockholders",
        "repeated_variables": "StockholderInfoSame",
        "repeated_pattern": {
          "id": "<<LOOP_INDEX>>",
          "name": {
            "legal_name": "Stockholder"
          },
          "issuer_assigned_id": "<<LOOP_INDEX>>",
          "primary_contact": {
            "name": {
              "legal_name": "Stockholder"
            },
            "emails": [
              {
                "email_address": "EmailAddress"
              }
            ],
            "phone_numbers": [
              {
                "phone_number": "PhoneNumber",
                "phone_type": {
                  "static": "HOME"
                }
              }
            ]
          },
          "addresses": [
            {
              "city": "StockholderCity",
              "country_subdivision": "StockholderState",
              "street_suite": "StockholderStreet",
              "postal_code": "StockholderZip"
            }
          ],
          "comments": [
            "|Auto-generated by CE2OCF Contract Express Parser v{{PARSER_VERSION}}|"
          ]
        }
      }
    ```
    if we registered a post_processor for `id` and `issuer_assigned_id` we can create a custom id based on the specific
    count of each stockholder - e.g.:
    ```python
        StockholderDataMap.register_handlers(
            {
                "id": lambda x, _: f"STOCKHOLDER.{x}",
                "issuer_assigned_id": lambda x, _: f"STOCKHOLDER.{x}",
            }
        )
    ```

- `Overridable*Field`: These templates are used for storing simple data types. They include `OverridableStringField`,
  `OverridableFloatField`, `OverridableBoolField`, and `OverridableIntField`. They allow
  you to specify a static value that overrides the value from the responses.

## OCF-Specific Datamaps

We've built a number of OCF datamaps that combine our base datamaps into complex objects that meet certain OCF schemas -
e.g. Stakeholders, Issuances, Issuer, Stock Legends, etc.

You can see how we've combined the [abstract datamap types](../Ce2Ocf/datamap/definitions.py) into [OCF-specific datamaps
definitions](../Ce2Ocf/ocf/datamaps.py).

While ce<sub>2</sub>OCF is targeted at producing OCF, you could leverage the base datamap types and our
traverse_datamap() function to build your own object definitions and create a parser to build such objects from CE
JSONs. Our OCF datamap types and default datamap implementation jsons should show you how to do this.

#  How Datamaps are Turned Into JSON Objects

The `traverse_datamap()` function uses **(1)** the datamap objects describing your target datashape and **(2)**
corresponding datamap JSONs describing what values to lookup to transform the responses. It reads the template, fetches
the corresponding values from the responses, applies any specified post-processing, and constructs the final object
according to the template. The result is a structured object that organizes the responses in a way that's much more
useful and easier to analyze. We have [extensive documentation on this function](configuring datamap lookups.md).

The provided code is a Python crawler that crawls Pydantic models and uses them to convert arbitrary data into the same
data shape as the shape specified by the Pydantic models.

# Overview of Each Datamap Type

## Base Datamaps

As described above, these are the building blocks that you can compose into complex schemas that can be used in
combination with `traverse_datamap()` to produce JSONs.

### `FieldPostProcessorModel`

This is a BaseModel subclass that provides the ability to register a post-processor function for individual fields.
This function will be run over the resulting model for a specified field.

### `Overridable*Field`

These are BaseModel subclasses that allow for the storage of different data types. They include:

- `OverridableStringField`: for storing `str` objects.
- `OverridableFloatField`: for storing `float` objects.
- `OverridableBoolField`: for storing `bool` objects.
- `OverridableIntField`: for storing `int` objects.

These classes have a single field, `static`, that holds the value of the appropriate type.

### `RepeatableDataMap`

This is a subclass of `FieldPostProcessorModel` and is used where you have some kind of repeated data structure. It has
three fields:

- `repeated_variables`: This field can hold a string, list of strings, `OverridableStringField`, or a list of
  `OverridableStringField`. It is used for variables that you want to look up on loop 1 and then apply its value
  to all iterations.
- `repeat_count`: This field can hold a string, `OverridableStringField`, or `OverridableIntField` and specifies the
  number of repetitions.
- `repeated_pattern`: This field can hold a dictionary, `BaseModel`, string, or `FieldPostProcessorModel` and defines
  the pattern to be repeated.

## OCF Datamaps

These are designed to extract valid OCF from CE JSONs specifically from Gunderson templates. Again, the datamap objects
define the target data shape you want and the specific values you look up to populate that data structure can then be
defined in a readily configurable datamap JSON. We've provided our [JSON datamaps](../Ce2Ocf/datamap/defaults) and these
are used by default.

**Here's an overview of the OCF Datamap Objects**

- `CurrencyDatamap`: This template is used to represent a currency value. It includes fields for the amount and the
  currency type.

- `RatioDatamap`: This template is used to represent a ratio. It includes fields for the numerator and the denominator.

- `AddressDataMap`: This template is used to represent an address. It includes fields for the address type, street,
  city, country subdivision, country, and postal code.

- `PhoneDataMap`: This template is used to represent a phone number. It includes fields for the phone type and the
  phone number.

- `IssuerDataMap`: This template is used to represent an issuer. It includes fields for the issuer's ID, legal name,
  DBA, country of formation, country subdivision of formation, formation date, object type, tax IDs, address, phone,
  and comments.

- `StockholderInfoDataMap`, `StockholderAddrDataMap`, `VestingDrivingEnumsDataMap`,
  `StockholderPreferredIssuancesDataMap`, `StockholderEmailDataMap`, `StockholderPrimaryContact`, `StockholderDataMap`:
  These templates are used to represent various aspects of a stockholder, including their legal name, address, email,
  phone numbers, and preferred issuances.

- `StockLegendDataMap`: This template is used to represent a stock legend. It includes fields for the ID, object type,
  comments, name, and text.

- `ConversionMechanismDataMap`, `ConversionRightsDataMap`: These templates are used to represent conversion rights.
  They include fields for the conversion type, conversion price, rounding type, ratio, and whether it converts to a
  future round.

- `StockClassDataMap`: This template is used to represent a stock class. It includes fields for the ID, name, object
  type, class type, default ID prefix, initial shares authorized, board approval date, votes per share, par value,
  price per share, seniority, conversion rights, liquidation preference multiple, participation cap multiple, and
  comments.

- `StockPlanDataMap`: This template is used to represent a stock plan. It includes fields for the ID, object type,
  plan name, stock class ID, board approval date, stockholder approval date, initial shares reserved, and comments.

- `VestingStockIssuanceDataMap`, `FullyVestedStockIssuanceDataMap`: These templates are used to represent a stock
  issuance. They include fields for the ID, date, object type, security ID, custom ID, comments, stakeholder ID, board
  approval date, consideration text, security law exemptions, stock class ID, share price, quantity, cost basis, and
  stock legend IDs.

- `VestingEventsInputsDataMap`, `VestingScheduleInputsDataMap`: These templates are used to represent vesting events
  and schedules. They include a field for the vesting schedule.

- `RepeatableVestingEventDriversDataMap`, `RepeatableVestingScheduleDriversDataMap`, `RepeatableStockholderDataMap`,
  `RepeatableFullyVestedStockIssuanceDataMap`, `RepeatableVestingStockIssuanceDataMap`: These templates are used to
  represent repeatable data structures. They include a field for the repeated pattern.

Each of these templates is used to define a specific part of the target object schema. They specify how values from
the responses map to this schema, and can be used in combination to build complex objects.
